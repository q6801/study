# TCP의 신뢰 전송
- [용어들](#용어들)
- [신뢰성 있는 네트워크를 유지하기 위해 해결해야하는 문제점들](#신뢰성-있는-네트워크를-유지하기-위해-해결해야하는-문제점들)
- [흐름 제어](#흐름-제어)
- [Stop and Wait 방법](#stop-and-wait-방법)
- [GoBackN (Sliding window)](#gobackn-sliding-window)
- [SelectiveRepeat (Sliding window)](#selectiverepeat-sliding-window)
- [TCP 신뢰전송과 혼잡제어](#tcp-신뢰전송과-혼잡제어)
- [참고](#참고)
  
</br>

# 용어들

- **ack 메시지** : 수신자가 정상적으로 수신하면 송신자에게 다시 메시지를 보내준다
- **nak 메시지** : 수신자가 정상적으로 수신 못해서 송신자에게 메시지 보내줌
- **윈도우** : 송신, 수신 스테이션 양쪽에서 만들어진 버퍼의 크기
- **윈도우 크기**
    - 한번에 받을 수 있는 데이터 량 (순서번호 이용)
    - **수신 윈도우 크기(RWND)**(내가 받을 수 있는 패킷의 수)는 할당받은 소켓 자료구조의 버퍼의 여유 공간에 따라서 결정된다.
    - 즉, 가변적인 값이다.
</br>


# 신뢰성 있는 네트워크를 유지하기 위해 해결해야하는 문제점들

- TCP는 신뢰성을 보장하는 연결형 서비스로 다음4가지의 문제점을 해결해야한다.
- 손상 (corruption)
    - 내가 전송했는데 잘못 수신된 경우 (값이 바뀌어서 오는 경우) 1이 0으로 바뀜
    - 무선 링크, 케이블에서 일어나는 오류
- 손실 (loss)
    - 버퍼가 오버플로우가 일어났을 때. 대부분 라우터에서 일어남
- 순서 바뀜
    - 패킷을 보내면 같은 경로를 따라서 전송되지 않는다. 각각이 독립적으로 그 상황에 적합한 경로로 간다. -> **순서가 뒤바뀌어서 도착 가능**
- 중복
    - 수신자가 데이터를 받았는데 받았다는 메시지를 송신자가 못받아서 재전송을 한 경우
- TCP는 세그먼트를 수신하면 ACK을 보내는 방식을 이용해 손상, 손실, 중복, 순서 바뀜을 방지한다.
- 물론 처리하는 로직은 아래 나오는 흐름 제어 방식에 따라서 달라진다.
</br>



# 흐름 제어

- 호스트와 호스트 간의 데이터 처리를 효율적으로 하기 위한 기법
- 즉, 송신측과 수신측의 **데이터 처리 속도 차이를 해결**하는 방법이다.
- 수신측의 데이터 처리 속도가 송신측이 보내는 데이터 속도가 더 빠르면, 수신측에서 받을 수 있는 한계량을 넘어서 데이터의 손실이 생긴다.
- 방법으로는 stop and wait, 슬라이딩 윈도우 등의 방법이 있다.
</br>

# Stop and Wait 방법

방법 설명

- 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
- 패킷을 하나씩 보내기 때문에 비효율적인 방법이다.

문제 상황

- ack을 보냈는데 못받은 경우에 중복된 수신
- ack을 보냈는데 timeout되면 중복 수신

해결 방법

- 모든 패킷에 순서번호를 부여하고 ack, nak 손상 시 패킷을 재전송한다.
- 일정 시간 지나도 ack 안오면 오류로 처리, 재전송한다.
- (패킷에 일련번호가 있어 수신자가 중복인지 여부를 확인 가능하다.)

stop and wait의 한계점

- 패킷 하나 하나 ack을 대기하는 시간이 있어서 네트워크 자원 낭비가 크다.
</br>

# GoBackN (Sliding window)

방법 설명

- 수신측에서 설정한 **윈도우 크기만큼** 송신측에서 확인응답없이 세그먼트를 전송하는 방법이다.
- sender가 receiver에게 윈도우 크기만큼 패킷들을 보낸다. → receiver는 손실, 손상된 패킷에 대해 ack을 보내지 않는다.→ sender는 ack을 받지 못한 패킷이 timeout되고 그 패킷부터 다시 보내준다.
- 잘못된 순서로 패킷이 오면 원래 순서에 맞는 패킷 말고는 전부 버리고 sender에게 다음 순서를 재요청한다

문제 가정 (한정된 순서번호를 사용할 때 패킷손실)

- (수신자의 버퍼의 크기는 256보다 크다고 가정) 송신자가 한번에 보낼 수 있는 패킷의 수는? (순서번호의 범위는 0, 255)
- 256개를 보냄 -> 수신자가 정상적으로 받음 -> ack를 보냈지만 다 손실 -> 수신자는 정상적으로 받았으니 다음 패킷 기다림(0번을 기다림 255번까지 왔으니깐) -> 송신자는 ack가 안와서 다시 재전송 (0번부터) -> 수신자는 구별 불가능
- 그래서 254번까지 보낼 수 있다. (255개) 즉, 2^n-2번까지 가능 (결론은 순서번호의 범위에 따라서 변한다는 것이다.)

go back N의 단점

- 하나의 잘못된 패킷으로 이미 받은 것들(아까 패킷 다음 순서들)을 다 버리고 재요청하기 때문에 비효율적이다.
- 이런 비효율을 해결하고자 sender가 받지 않은 ack만 재전송 하는 방식이 selective repeat이다.

</br>

# SelectiveRepeat (Sliding window)

방법 설명

- gbn이랑 다르게 값이 여러개 올 때 순서와 상관없이 온 모든 패킷에 대하여 ack을 보내준다. 그렇게 온 패킷들은 buffer를 유지해서 나머지 패킷들도 오기를 기다린다. 그 전까지는 올려보내지 않는다.
- 데이터가 오지 못하고 손상되면 timeout으로 재전송해서 온다.
- 수신자가 buffer를 유지함

문제 가정 (한정된 순서번호를 사용할 때 패킷손실)

- (수신자의 버퍼의 크기는 256보다 크다고 가정) 송신자가 한번에 보낼 수 있는 패킷의 수는? (순서번호의 범위는 0, 255)
- 130개를 보냄 -> 수신자가 정상적으로 받음 -> ack를 보냈지만 다 손실 -> 수신자는 정상적으로 받았으니 다음 패킷 기다림(0번을 기다림 129번까지 왔으니깐) -> 송신자는 ack가 안와서 다시 재전송 (0번부터) -> 수신자는 번호 구별이 안됨
    - 수신자가 받아야하는 다음 번호는 131 ~ 255번 + 0~1번이다. (왜냐하면 순서 번호의 절반인 128개를 넘었으니 다시 0부터 시작해야한다.)
    - 이 때 0, 1이 재전송된 순서번호인지 다음 순서번호인지 구별할 수 없다.
- 그래서 절반까지 가능 즉, 127번까지 가능, 아니면 selectiveRepeat이 재전송인지 아닌지 구별이 불가능.

</br>

# TCP 신뢰전송과 혼잡제어

- 실제로 TCP는 selectiveRepeat과 go back n을 섞어서 사용
    - 패킷이 누락될 경우의 처리를 혼잡제어를 통해 진행한다.
- TCP는 3가지의 상태를 가진다.
    - Slow Start
        - 시작시점 혹은 타임아웃이 발생했을 때, 윈도우 사이즈가 1부터 지수함수 꼴로 증가하면서 전송하는 상태
    - Congestion Avoidance
        - slow start에서 지수함수로 증가시키다가 ssthreshold(일반적으로 지난 timeout의 1/2)가 되는 사이즈부터 window size를 선형적으로 증가하며 패킷을 전송하는 상태
    - fast recovery
        - duplicated ack이 3개 이상일 때 변경되는 상태로이다.
        - 현재 윈도우크기로 계산한 ssthresold를 윈도우크기로 두었을 때 timeout이 일어나면 slowstart, 새로운 ack이 오면 congestion avoidance로 상태를 바꾼다.
- **혼잡 제어와 wnd 크기**
    - 송신 측은 자신의 최종 윈도우 크기를 정할 때 수신 측이 보내준 윈도우 크기인 **`수신자 윈도우(RWND)`**, 그리고 자신이 네트워크의 상황을 고려해서 정한 윈도우 크기인 **`혼잡 윈도우(CWND)`** 중에서 더 작은 값을 사용한다.
    - 즉, 혼잡 제어 기법들이 늘였다 줄였다 하는 윈도우 크기는 송신 윈도우가 아니라 송신 측이 가지고 있는 **`혼잡 윈도우 크기`**인 것이다
  
</br>

# 참고

[[Network 01] TCP는 GBN( Go Back N ) 방식으로 동작할까, SR( Selective Repeat ) 방식으로 동작할까?](https://blog.naver.com/PostView.naver?blogId=whdgml1996&logNo=222148180270&parentCategoryNo=&categoryNo=83&viewDate=&isShowPopularPosts=false&from=postView)

[사이 좋게 네트워크를 나눠 쓰는 방법, TCP의 혼잡 제어](https://evan-moon.github.io/2019/11/26/tcp-congestion-control/)